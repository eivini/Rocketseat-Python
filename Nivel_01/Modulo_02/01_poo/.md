<div>
  <h1>
    Programação Orientada a Objetos <b>(POO)</b>
  </h1>
  <p>
    A Programação Orientada a Objetos (POO) é um paradigma de programação baseado no conceito de "objetos". Objetos são instâncias de classes, que podem conter atributos (dados) e métodos (funções que realizam operações com os dados). A POO visa tornar o código mais modular, reutilizável e mais fácil de entender e manter.
  </p>
</div>

<div>
  <h1>
    Os 4 pilares da POO:
  </h1>

  <h3>
    Abstração:
  </h3>
  <p>
    A abstração é o processo de esconder os detalhes complexos e mostrar apenas o necessário. Em Python, você pode usar classes para criar uma abstração do mundo real.
  </p>
  <ul>
    <li><b>Exemplo</b>: <br>
      Uma classe Carro pode ter atributos como modelo, cor e ano, mas o funcionamento interno (como o motor) pode ser oculto, oferecendo apenas métodos para acelerar ou frear.
    </li>
  </ul>

  ```python
  class Carro:
      def __init__(self, modelo, cor, ano):
          self.modelo = modelo
          self.cor = cor
          self.ano = ano

      def acelerar(self):
          print("O carro acelerou!")

      def frear(self):
          print("O carro freou!")
  ```

</div>

<div>
  <h3>
    Encapsulamento:
  </h3>
  <p>
    O encapsulamento refere-se à prática de esconder o estado interno de um objeto e fornecer uma interface pública para interagir com ele.
  </p>
  <ul>
    <li><b>Exemplo</b>: <br>
      Em Python, você pode usar métodos getter e setter para acessar e modificar atributos privados (embora não haja modificadores de acesso rígidos como em outras linguagens, como Java, o padrão é usar convenções de nomes com underline, como self._atributo).
    </li>
  </ul>

  ```python
  class Carro:
      def __init__(self, modelo, cor, ano):
          self._modelo = modelo
          self._cor = cor
          self._ano = ano

      def get_modelo(self):
          return self._modelo

      def set_modelo(self, modelo):
          self._modelo = modelo
  ```

</div>

<div>
  <h3>
    Herança:
  </h3>
  <p>
    A herança permite que uma classe herde atributos e métodos de outra, promovendo a reutilização de código.
  </p>
  <ul>
    <li><b>Exemplo</b>: <br>
      Em Python, uma classe pode herdar de outra simplesmente colocando o nome da classe base entre parênteses ao definir a nova classe.
    </li>
  </ul>

  ```python
  class Veiculo:
      def __init__(self, modelo):
          self.modelo = modelo

      def ligar(self):
          print("O veículo ligou!")

  class Carro(Veiculo):
      def __init__(self, modelo, cor):
          super().__init__(modelo)
          self.cor = cor

      def buzinar(self):
          print("Buzinando!")
  ```

</div>

<div>
  <h3>
    Polimorfismo:
  </h3>
  <p>
    O polimorfismo permite que diferentes classes implementem métodos com o mesmo nome, mas com comportamentos diferentes.
  </p>
  <ul>
    <li><b>Exemplo</b>: <br>
      Em Python, isso pode ser feito por meio de sobrescrita de métodos.
    </li>
  </ul>

  ```python
  class Animal:
      def fazer_som(self):
          print("O animal faz um som.")

  class Cachorro(Animal):
      def fazer_som(self):
          print("O cachorro late.")

  class Gato(Animal):
      def fazer_som(self):
          print("O gato mia.")
  ```

</div>

<div>
  <h3>
    Testando o polimorfismo:
  </h3>

  ```python
  animais = [Cachorro(), Gato()]
  for animal in animais:
      animal.fazer_som()  # Cada um faz um som diferente
  ```
</div>