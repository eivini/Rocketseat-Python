<div>
  <h1>Decoradores em <b>Python</b></h1>
  <p>
    Um decorador em Python é uma função que modifica o comportamento de outra função, método ou classe.
    Ele "decora" uma função, ou seja, adiciona funcionalidades antes ou depois da execução dessa função,
    sem modificar o código original.
  </p>
  <p>
    Em termos simples, um decorador é uma função que recebe outra função como argumento e retorna uma nova função
    que, normalmente, executa algo antes ou depois da função original.
  </p>
</div>

<div>
  <h2>Como funciona um Decorador?</h2>
  <p>
    Em Python, você pode usar a sintaxe <code>@decorator</code> antes da definição de uma função para aplicar o decorador.
    O que acontece por trás dos panos é que o decorador substitui a função original pela função decorada.
  </p>
</div>

<div>
  <h3>Exemplo básico de um Decorador:</h3>
  <p>Vamos criar um decorador simples que imprime uma mensagem antes de chamar a função decorada.</p>

  ```python
  # Definindo o decorador
  def meu_decorador(func):
      def wrapper():
          print("Antes da execução da função.")
          func()  # Chama a função original
          print("Depois da execução da função.")
      return wrapper

  # Aplicando o decorador à função
  @meu_decorador
  def minha_funcao():
      print("Executando minha função.")

  # Chamando a função decorada
  minha_funcao()
  ```

  <p><b>Saída:</b></p>

  ```
  Antes da execução da função.
  Executando minha função.
  Depois da execução da função.
  ```

  <p><b>Explicação:</b></p>
  <p>
    O decorador <code>meu_decorador</code> recebe a função <code>minha_funcao</code> como argumento e cria uma nova função
    <code>wrapper</code> que envolve a execução de <code>minha_funcao</code>. Quando chamamos <code>minha_funcao()</code>,
    o que realmente está acontecendo é a chamada de <code>wrapper()</code>, que executa o código extra e, em seguida,
    chama a função original.
  </p>
</div>

<div>
  <h2>Decoradores Comuns</h2>
  <p>Decoradores comuns em Python são utilizados para tarefas como verificação de acesso, medição de tempo, logging etc.</p>
</div>

<div>
  <h3>1. Decorador para medir o tempo de execução</h3>
  <p>Este decorador mede quanto tempo uma função leva para ser executada.</p>

  ```python
  import time

  def medir_tempo(func):
      def wrapper(*args, **kwargs):
          inicio = time.time()
          resultado = func(*args, **kwargs)  # Executa a função
          fim = time.time()
          print(f"Tempo de execução: {fim - inicio:.2f} segundos.")
          return resultado
      return wrapper

  @medir_tempo
  def exemplo_lento():
      time.sleep(2)  # Simula uma operação demorada

  exemplo_lento()
  ```

  <p><b>Saída:</b></p>

  ```
  Tempo de execução: 2.00 segundos.
  ```

  <p><b>Explicação:</b> O decorador <code>medir_tempo</code> calcula o tempo antes e depois da execução da função original.</p>
</div>

<div>
  <h3>2. Decorador para verificar permissão de acesso</h3>
  <p>Este decorador verifica se o usuário tem permissão antes de executar a função.</p>

  ```python
  def verificar_permissao(func):
      def wrapper(usuario, *args, **kwargs):
          if usuario == "admin":
              return func(usuario, *args, **kwargs)
          else:
              print(f"Usuário {usuario} não tem permissão!")
              return None
      return wrapper

  @verificar_permissao
  def acessar_area_restrita(usuario):
      print(f"Bem-vindo à área restrita, {usuario}!")

  acessar_area_restrita("admin")    # Permissão concedida
  acessar_area_restrita("usuario")  # Permissão negada
  ```

  <p><b>Saída:</b></p>

  ```
  Bem-vindo à área restrita, admin!
  Usuário usuario não tem permissão!
  ```

  <p><b>Explicação:</b>
    O decorador <code>verificar_permissao</code> verifica se o nome do usuário é "admin".
    Se for, a função original é executada. Caso contrário, uma mensagem de acesso negado é exibida.
  </p>
</div>

<div>
  <h3>3. Decoradores aninhados (stacking)</h3>
  <p>Você pode empilhar decoradores em uma função. A ordem importa!</p>

  ```python
  def negrito(func):
      def wrapper():
          return f"<b>{func()}</b>"
      return wrapper

  def italico(func):
      def wrapper():
          return f"<i>{func()}</i>"
      return wrapper

  @negrito
  @italico
  def mensagem():
      return "Olá!"

  print(mensagem())  # Saída: <b><i>Olá!</i></b>
  ```

  <p><b>Explicação:</b> O decorador mais próximo da função é aplicado primeiro. Nesse exemplo, <code>italico</code> é aplicado antes de <code>negrito</code>.</p>
</div>

<div>
  <h3>4. Decoradores com argumentos variados</h3>
  <p>Podem receber e repassar argumentos usando <code>*args</code> e <code>**kwargs</code>.</p>

  ```python
  def log(func):
      def wrapper(*args, **kwargs):
          print(f"Chamando {func.__name__} com argumentos {args} e {kwargs}")
          return func(*args, **kwargs)
      return wrapper

  @log
  def soma(a, b):
      return a + b

  resultado = soma(3, 5)
  print(f"Resultado: {resultado}")
  ```

  <p><b>Saída:</b></p>

  ```
  Chamando soma com argumentos (3, 5) e {}
  Resultado: 8
  ```

  <p><b>Explicação:</b> O decorador <code>log</code> mostra o nome da função e os argumentos passados, antes de executar a função original.</p>
</div>
